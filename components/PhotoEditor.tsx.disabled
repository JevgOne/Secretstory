"use client";

import { useRef, useEffect, useState } from 'react';
// @ts-ignore - fabric types issue
import { fabric } from 'fabric';

interface PhotoEditorProps {
  imageUrl: string;
  onSave: (editedImageDataUrl: string) => void;
  onCancel: () => void;
}

export default function PhotoEditor({ imageUrl, onSave, onCancel }: PhotoEditorProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [canvas, setCanvas] = useState<fabric.Canvas | null>(null);
  const [originalImage, setOriginalImage] = useState<fabric.Image | null>(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [brushSize, setBrushSize] = useState(50);
  const blurredAreasRef = useRef<any[]>([]);

  // Initialize canvas
  useEffect(() => {
    if (!canvasRef.current) return;

    const fabricCanvas = new fabric.Canvas(canvasRef.current, {
      width: 800,
      height: 600,
      backgroundColor: '#000'
    });

    // Load image
    fabric.Image.fromURL(imageUrl, (img) => {
      // Scale image to fit canvas
      const scale = Math.min(
        800 / (img.width || 800),
        600 / (img.height || 600)
      );

      img.scale(scale);
      img.set({
        left: (800 - (img.width || 0) * scale) / 2,
        top: (600 - (img.height || 0) * scale) / 2,
        selectable: false,
        evented: false
      });

      fabricCanvas.add(img);
      fabricCanvas.sendToBack(img);
      setOriginalImage(img);
    });

    setCanvas(fabricCanvas);

    return () => {
      fabricCanvas.dispose();
    };
  }, [imageUrl]);

  // Apply blur when drawing
  const applyBlurAtPoint = (pointer: { x: number; y: number }) => {
    if (!canvas || !originalImage) return;

    // Create blur circle
    const circle = new fabric.Circle({
      left: pointer.x - brushSize / 2,
      top: pointer.y - brushSize / 2,
      radius: brushSize / 2,
      fill: 'rgba(255, 255, 255, 0.5)',
      stroke: 'rgba(255, 255, 255, 0.8)',
      strokeWidth: 2,
      selectable: false,
      evented: false,
      opacity: 0.8
    });

    // Apply blur filter
    circle.filters = [
      new fabric.Image.filters.Blur({ blur: 0.8 })
    ];

    canvas.add(circle);
    blurredAreasRef.current.push(circle);
    canvas.renderAll();
  };

  // Mouse down - start drawing
  const handleMouseDown = (e: any) => {
    if (!isDrawing) return;
    const pointer = canvas?.getPointer(e.e);
    if (pointer) {
      applyBlurAtPoint(pointer);
    }
  };

  // Mouse move - continue drawing
  const handleMouseMove = (e: any) => {
    if (!isDrawing || !canvas) return;
    const pointer = canvas.getPointer(e.e);
    if (pointer) {
      applyBlurAtPoint(pointer);
    }
  };

  // Setup drawing events
  useEffect(() => {
    if (!canvas) return;

    canvas.on('mouse:down', handleMouseDown);
    canvas.on('mouse:move', handleMouseMove);

    return () => {
      canvas.off('mouse:down', handleMouseDown);
      canvas.off('mouse:move', handleMouseMove);
    };
  }, [canvas, isDrawing, brushSize]);

  // Toggle drawing mode
  const toggleDrawing = () => {
    setIsDrawing(!isDrawing);
    if (canvas) {
      canvas.isDrawingMode = false; // We use custom drawing
    }
  };

  // Clear all blur
  const clearBlur = () => {
    if (!canvas) return;

    blurredAreasRef.current.forEach(obj => {
      canvas.remove(obj);
    });
    blurredAreasRef.current = [];
    canvas.renderAll();
  };

  // Undo last blur
  const undoLast = () => {
    if (!canvas || blurredAreasRef.current.length === 0) return;

    const lastBlur = blurredAreasRef.current.pop();
    canvas.remove(lastBlur);
    canvas.renderAll();
  };

  // Save edited image
  const handleSave = () => {
    if (!canvas) return;

    // Export canvas as data URL
    const dataUrl = canvas.toDataURL({
      format: 'jpeg',
      quality: 0.9
    });

    onSave(dataUrl);
  };

  return (
    <div className="photo-editor-modal">
      <div className="photo-editor-container">
        <h3>Upravit fotku</h3>
        <p className="editor-instruction">
          Pou≈æij ≈°tƒõtec k rozmaz√°n√≠ obliƒçeje nebo tetov√°n√≠
        </p>

        <div className="canvas-wrapper">
          <canvas ref={canvasRef} />
        </div>

        <div className="editor-controls">
          <div className="brush-controls">
            <button
              className={`tool-btn ${isDrawing ? 'active' : ''}`}
              onClick={toggleDrawing}
            >
              üñåÔ∏è {isDrawing ? 'Zastavit' : 'Blur ≈°tƒõtec'}
            </button>

            <div className="brush-size-control">
              <label>Velikost ≈°tƒõtce: {brushSize}px</label>
              <input
                type="range"
                min="20"
                max="100"
                value={brushSize}
                onChange={(e) => setBrushSize(Number(e.target.value))}
              />
            </div>
          </div>

          <div className="action-buttons">
            <button onClick={undoLast} className="undo-btn">
              ‚Ü©Ô∏è Zpƒõt
            </button>
            <button onClick={clearBlur} className="clear-btn">
              üóëÔ∏è Vymazat v≈°e
            </button>
          </div>
        </div>

        <div className="save-buttons">
          <button onClick={onCancel} className="cancel-btn">
            Zru≈°it
          </button>
          <button onClick={handleSave} className="save-btn">
            Ulo≈æit upravenou fotku
          </button>
        </div>
      </div>

      <style jsx>{`
        .photo-editor-modal {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.9);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
          padding: 20px;
        }

        .photo-editor-container {
          background: white;
          border-radius: 12px;
          padding: 30px;
          max-width: 900px;
          width: 100%;
          max-height: 90vh;
          overflow-y: auto;
        }

        h3 {
          margin: 0 0 10px 0;
          font-size: 24px;
          color: #333;
        }

        .editor-instruction {
          color: #666;
          margin-bottom: 20px;
        }

        .canvas-wrapper {
          border: 2px solid #ddd;
          border-radius: 8px;
          overflow: hidden;
          margin-bottom: 20px;
          background: #f0f0f0;
        }

        .editor-controls {
          display: flex;
          flex-direction: column;
          gap: 20px;
          margin-bottom: 20px;
        }

        .brush-controls {
          display: flex;
          flex-direction: column;
          gap: 15px;
        }

        .tool-btn {
          padding: 12px 24px;
          border: 2px solid #ec4899;
          background: white;
          color: #ec4899;
          border-radius: 8px;
          font-size: 16px;
          cursor: pointer;
          transition: all 0.3s;
        }

        .tool-btn.active {
          background: #ec4899;
          color: white;
        }

        .tool-btn:hover {
          background: #ec4899;
          color: white;
        }

        .brush-size-control {
          display: flex;
          flex-direction: column;
          gap: 8px;
        }

        .brush-size-control label {
          font-size: 14px;
          color: #666;
        }

        .brush-size-control input[type="range"] {
          width: 100%;
          height: 6px;
          border-radius: 3px;
          background: #ddd;
          outline: none;
        }

        .brush-size-control input[type="range"]::-webkit-slider-thumb {
          appearance: none;
          width: 20px;
          height: 20px;
          border-radius: 50%;
          background: #ec4899;
          cursor: pointer;
        }

        .action-buttons {
          display: flex;
          gap: 10px;
        }

        .undo-btn,
        .clear-btn {
          flex: 1;
          padding: 10px;
          border: 1px solid #ddd;
          background: white;
          border-radius: 6px;
          cursor: pointer;
          font-size: 14px;
          transition: all 0.2s;
        }

        .undo-btn:hover,
        .clear-btn:hover {
          background: #f5f5f5;
          border-color: #ec4899;
        }

        .save-buttons {
          display: flex;
          gap: 15px;
          margin-top: 20px;
          padding-top: 20px;
          border-top: 1px solid #eee;
        }

        .cancel-btn,
        .save-btn {
          flex: 1;
          padding: 14px;
          border: none;
          border-radius: 8px;
          font-size: 16px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.3s;
        }

        .cancel-btn {
          background: #e5e7eb;
          color: #374151;
        }

        .cancel-btn:hover {
          background: #d1d5db;
        }

        .save-btn {
          background: #ec4899;
          color: white;
        }

        .save-btn:hover {
          background: #db2777;
        }

        @media (max-width: 768px) {
          .photo-editor-container {
            padding: 20px;
          }

          .canvas-wrapper canvas {
            max-width: 100%;
            height: auto !important;
          }
        }
      `}</style>
    </div>
  );
}
